@using System.Globalization
@inherits RadzenComponent
@{
    // Build the QR matrix
    bool[,] modules = RadzenQREncoder.EncodeUtf8(Value, RadzenQREcc.Quartile);
    int n = modules.GetLength(0);
    int vb = n + 8; // quiet zone

    // --- Center Image math (viewBox units == modules incl. quiet zone) ---
    bool hasImage = !string.IsNullOrWhiteSpace(Image);
    // Clamp percent for scan reliability (5%..60% of QR inner box)
    double pct = Clamp(ImageSizePercent, 5, 60);
    double boxModules = Math.Max(5, Math.Round(n * (pct / 100.0)));
    double pad = Math.Max(0, ImagePaddingModules);

    double cutoutW = boxModules + 2 * pad;
    double cutoutH = boxModules + 2 * pad;

    double centerX = vb / 2.0;
    double centerY = vb / 2.0;

    double cutoutX = centerX - cutoutW / 2.0;
    double cutoutY = centerY - cutoutH / 2.0;
    double imgX = centerX - boxModules / 2.0;
    double imgY = centerY - boxModules / 2.0;

    string imgHref = NormalizeImageHref(Image);
}

<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 @vb @vb"
     shape-rendering="crispEdges"
     width="@Size"
     height="@Size"
     @ref="@Element" style="@Style" @attributes="Attributes" class="@GetCssClass()" id="@GetId()">
    <!-- Background -->
    <rect x="0" y="0" width="@vb" height="@vb" fill="@Background" />

    @if (modules is not null)
    {
        <!-- finder patterns / eyes -->
        @DrawEye(4, 4, EyeShapeTopLeft ?? EyeShape, EyeColorTopLeft ?? EyeColor ?? Foreground)
        @DrawEye(vb - 11, 4, EyeShapeTopRight ?? EyeShape, EyeColorTopRight ?? EyeColor ?? Foreground)
        @DrawEye(4, vb - 11, EyeShapeBottomLeft ?? EyeShape, EyeColorBottomLeft ?? EyeColor ?? Foreground)

        <!-- data modules (skip eye regions) -->
        @for (var r = 0; r < n; r++)
        {
            for (var c = 0; c < n; c++)
            {
                if (!modules[r, c]) continue;
                if (IsFinderCell(r, c, n)) continue; // don't overdraw eyes

                var x = c + 4; // quiet zone offset
                var y = r + 4;

                if (ModuleShape == QRCodeModuleShape.Circle)
                {
                    <circle cx="@Format(x + 0.5)" cy="@Format(y + 0.5)" r="0.5" fill="@Foreground" />
                }
                else if (ModuleShape == QRCodeModuleShape.Rounded)
                {
                    <rect x="@Format(x)" y="@Format(y)" width="1" height="1" rx="0.25" ry="0.25" fill="@Foreground" />
                }
                else
                {
                    <rect x="@Format(x)" y="@Format(y)" width="1" height="1" fill="@Foreground" />
                }
            }
        }

        @* Center image overlay (cutout + image) *@
        @if (hasImage)
        {
            <!-- white (configurable) rounded cutout for the logo -->
            <rect x="@Format(cutoutX)"
                  y="@Format(cutoutY)"
                  width="@Format(cutoutW)"
                  height="@Format(cutoutH)"
                  rx="@Format(ImageCornerRadius)"
                  ry="@Format(ImageCornerRadius)"
                  fill="@ImageBackground"
                  fill-opacity="@Format(Clamp(ImageBackgroundOpacity, 0, 1))" />

            <!-- the logo image -->
            <image x="@Format(imgX)"
                   y="@Format(imgY)"
                   width="@Format(boxModules)"
                   height="@Format(boxModules)"
                   preserveAspectRatio="xMidYMid meet"
                   href="@imgHref" />
        }
    }
</svg>

@code
{
    // ---------- Helpers ----------
    private static string Format(double v) => v.ToString(CultureInfo.InvariantCulture);

    private static bool IsFinderCell(int r, int c, int n)
    {
        bool inTL = r < 7 && c < 7;
        bool inTR = r < 7 && c >= n - 7;
        bool inBL = r >= n - 7 && c < 7;
        return inTL || inTR || inBL;
    }

    private static double Clamp(double v, double lo, double hi) => v < lo ? lo : (v > hi ? hi : v);

    private static string NormalizeImageHref(string? image)
    {
        if (string.IsNullOrWhiteSpace(image)) return string.Empty;
        var href = image.Trim();
        bool looksUrl = href.Contains("://", StringComparison.OrdinalIgnoreCase);
        bool isData = href.StartsWith("data:", StringComparison.OrdinalIgnoreCase);
        if (!looksUrl && !isData)
        {
            // assume raw base64 png
            href = "data:image/png;base64," + href;
        }
        return href;
    }

    // Draw a 7x7 eye whose top-left screen coordinate (including quiet zone) is (x,y).
    // NOTE: x,y are *SVG units* (already offset by quiet zone).
    private RenderFragment DrawEye(double x, double y, QRCodeEyeShape shape, string color) => builder =>
    {
        int seq = 0;

        // helpers
        void Rect(double rx, double ry, double w, double h, double? cr = null)
        {
            builder.OpenElement(seq++, "rect"); builder.AddAttribute(seq++, "x", Format(rx));
            builder.AddAttribute(seq++, "y", Format(ry)); builder.AddAttribute(seq++, "width", Format(w));
            builder.AddAttribute(seq++, "height", Format(h)); builder.AddAttribute(seq++, "fill", color);
            if (cr is not null) { builder.AddAttribute(seq++, "rx", Format(cr.Value)); builder.AddAttribute(seq++, "ry", Format(cr.Value)); }
            builder.CloseElement();
        }

        void RingSquare(double tx, double ty, double size, double thick, double? cr = null)
        {
            // Outer square
            builder.OpenElement(seq++, "rect");
            builder.AddAttribute(seq++, "x", Format(tx));
            builder.AddAttribute(seq++, "y", Format(ty));
            builder.AddAttribute(seq++, "width", Format(size));
            builder.AddAttribute(seq++, "height", Format(size));
            if (cr is not null) { builder.AddAttribute(seq++, "rx", Format(cr.Value)); builder.AddAttribute(seq++, "ry", Format(cr.Value)); }
            builder.AddAttribute(seq++, "fill", color);
            builder.CloseElement();

            // Inner hole (draw as background)
            builder.OpenElement(seq++, "rect");
            builder.AddAttribute(seq++, "x", Format(tx + thick));
            builder.AddAttribute(seq++, "y", Format(ty + thick));
            builder.AddAttribute(seq++, "width", Format(size - 2 * thick));
            builder.AddAttribute(seq++, "height", Format(size - 2 * thick));
            if (cr is not null) { builder.AddAttribute(seq++, "rx", Format(Math.Max(0, cr.Value - thick))); builder.AddAttribute(seq++, "ry", Format(Math.Max(0, cr.Value - thick))); }
            builder.AddAttribute(seq++, "fill", Background);
            builder.CloseElement();
        }

        switch (shape)
        {
            case QRCodeEyeShape.Rounded:
                // 7x7 outer with rounded corners; 5x5 inner hole; 3x3 pupil
                RingSquare(x, y, 7, 1, cr: 1.25);
                Rect(x + 2, y + 2, 3, 3, cr: 0.75); // pupil
                break;

            case QRCodeEyeShape.Framed:
                // Square ring (bold frame) + square pupil
                RingSquare(x, y, 7, 1.2);
                Rect(x + 2, y + 2, 3, 3);
                break;

            case QRCodeEyeShape.Square:
            default:
                // Classic: outer 7x7 square, inner white 5x5, center 3x3 dark
                Rect(x, y, 7, 7);
                builder.OpenElement(seq++, "rect");
                builder.AddAttribute(seq++, "x", Format(x + 1));
                builder.AddAttribute(seq++, "y", Format(y + 1));
                builder.AddAttribute(seq++, "width", Format(5));
                builder.AddAttribute(seq++, "height", Format(5));
                builder.AddAttribute(seq++, "fill", Background);
                builder.CloseElement();
                Rect(x + 2, y + 2, 3, 3);
                break;
        }
    };
}
